import credits.aleo;
import dcp_destination_shares.aleo;
import dcp_reconstruct_secret.aleo;
import dcp_validator_shares.aleo;
import dcp_open_requests.aleo;
import dcp_validator_fee.aleo;
import dcp_core_protocol.aleo;
import data_custody_protocol.aleo;
import dcp_beaver_intermediaries.aleo;
program dcp_beaver_triples.aleo;


struct Share:
    share_val as field;
    index as field;

struct Custody:
    origin as address;
    custody_key as field;
    threshold as u8;



struct Beaver:
    triple_index as field;
    beaver_type as u8;
    validators as [address; 16u32];

struct ValidatorShareData:
    validator as address;
    share as Share;






struct Proposal:
    validators as [address; 16u32];
    threshold as u8;
    current_validator_set_index as u64;

struct Ciphertext:
    value_ as group;
    nonce as group;


record IntermediaryResult:
    owner as address.private;
    triple_index as field.private;
    ciphertexts as [Ciphertext; 16u32].private;
    step as boolean.private;







function generate_left_beaver:
    input r0 as field.public;
    input r1 as scalar.private;
    input r2 as scalar.private;
    input r3 as [address; 16u32].public;
    input r4 as u8.public;
    input r5 as [field; 15u32].private;
    input r6 as scalar.private;
    is.eq 0u8 r4 into r7;
    ternary r7 r3[0u32] aleo1qgqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqanmpl0 into r8;
    is.eq 1u8 r4 into r9;
    ternary r9 r3[1u32] r8 into r10;
    is.eq 2u8 r4 into r11;
    ternary r11 r3[2u32] r10 into r12;
    is.eq 3u8 r4 into r13;
    ternary r13 r3[3u32] r12 into r14;
    is.eq 4u8 r4 into r15;
    ternary r15 r3[4u32] r14 into r16;
    is.eq 5u8 r4 into r17;
    ternary r17 r3[5u32] r16 into r18;
    is.eq 6u8 r4 into r19;
    ternary r19 r3[6u32] r18 into r20;
    is.eq 7u8 r4 into r21;
    ternary r21 r3[7u32] r20 into r22;
    is.eq 8u8 r4 into r23;
    ternary r23 r3[8u32] r22 into r24;
    is.eq 9u8 r4 into r25;
    ternary r25 r3[9u32] r24 into r26;
    is.eq 10u8 r4 into r27;
    ternary r27 r3[10u32] r26 into r28;
    is.eq 11u8 r4 into r29;
    ternary r29 r3[11u32] r28 into r30;
    is.eq 12u8 r4 into r31;
    ternary r31 r3[12u32] r30 into r32;
    is.eq 13u8 r4 into r33;
    ternary r33 r3[13u32] r32 into r34;
    is.eq 14u8 r4 into r35;
    ternary r35 r3[14u32] r34 into r36;
    is.eq 15u8 r4 into r37;
    ternary r37 r3[15u32] r36 into r38;
    assert.eq r38 self.signer;
    is.neq r2 0scalar into r39;
    assert.eq r39 true;
    lte r1 1_000_000scalar into r40;
    gte r1 1_000_000scalar into r41;
    or r40 r41 into r42;
    assert.eq r42 true;
    mul r2 522678458525321116977504528531602186870683848189190546523208313015552693483group into r43;
    cast self.signer into r44 as group;
    mul r2 r44 into r45;
    mul r1 group::GEN into r46;
    add r46 r45 into r47;
    cast r47 r43 into r48 as Ciphertext;
    call dcp_beaver_intermediaries.aleo/sumbit_left_ciphers r3 r0 r4 r48 into r49 r50 r51 r52 r53 r54 r55 r56 r57 r58 r59 r60 r61 r62 r63 r64;
    cast r0 0u8 r3 into r65 as Beaver;
    hash.bhp256 r65 into r66 as field;
    cast r1 into r67 as field;
    call data_custody_protocol.aleo/add_or_mul_private r67 true r66 r5 r3 16u8 r6 into r68;
    async generate_left_beaver r68 into r69;
    output r69 as dcp_beaver_triples.aleo/generate_left_beaver.future;

finalize generate_left_beaver:
    input r0 as data_custody_protocol.aleo/add_or_mul_private.future;
    await r0;



function reconstruct_inter_ciphers:
    input r0 as dcp_beaver_intermediaries.aleo/IntermediaryCiphertext.record;
    input r1 as dcp_beaver_intermediaries.aleo/IntermediaryCiphertext.record;
    input r2 as dcp_beaver_intermediaries.aleo/IntermediaryCiphertext.record;
    input r3 as dcp_beaver_intermediaries.aleo/IntermediaryCiphertext.record;
    input r4 as dcp_beaver_intermediaries.aleo/IntermediaryCiphertext.record;
    input r5 as dcp_beaver_intermediaries.aleo/IntermediaryCiphertext.record;
    input r6 as dcp_beaver_intermediaries.aleo/IntermediaryCiphertext.record;
    input r7 as dcp_beaver_intermediaries.aleo/IntermediaryCiphertext.record;
    input r8 as dcp_beaver_intermediaries.aleo/IntermediaryCiphertext.record;
    input r9 as dcp_beaver_intermediaries.aleo/IntermediaryCiphertext.record;
    input r10 as dcp_beaver_intermediaries.aleo/IntermediaryCiphertext.record;
    input r11 as dcp_beaver_intermediaries.aleo/IntermediaryCiphertext.record;
    input r12 as dcp_beaver_intermediaries.aleo/IntermediaryCiphertext.record;
    input r13 as dcp_beaver_intermediaries.aleo/IntermediaryCiphertext.record;
    input r14 as dcp_beaver_intermediaries.aleo/IntermediaryCiphertext.record;
    input r15 as dcp_beaver_intermediaries.aleo/IntermediaryCiphertext.record;
    assert.eq r0.step r1.step;
    assert.eq r0.step r2.step;
    assert.eq r0.step r3.step;
    assert.eq r0.step r4.step;
    assert.eq r0.step r5.step;
    assert.eq r0.step r6.step;
    assert.eq r0.step r7.step;
    assert.eq r0.step r8.step;
    assert.eq r0.step r9.step;
    assert.eq r0.step r10.step;
    assert.eq r0.step r11.step;
    assert.eq r0.step r12.step;
    assert.eq r0.step r13.step;
    assert.eq r0.step r14.step;
    assert.eq r0.step r15.step;
    assert.eq r0.triple_index r1.triple_index;
    assert.eq r0.triple_index r2.triple_index;
    assert.eq r0.triple_index r3.triple_index;
    assert.eq r0.triple_index r4.triple_index;
    assert.eq r0.triple_index r5.triple_index;
    assert.eq r0.triple_index r6.triple_index;
    assert.eq r0.triple_index r7.triple_index;
    assert.eq r0.triple_index r8.triple_index;
    assert.eq r0.triple_index r9.triple_index;
    assert.eq r0.triple_index r10.triple_index;
    assert.eq r0.triple_index r11.triple_index;
    assert.eq r0.triple_index r12.triple_index;
    assert.eq r0.triple_index r13.triple_index;
    assert.eq r0.triple_index r14.triple_index;
    assert.eq r0.triple_index r15.triple_index;
    assert.eq r0.validator_index 0u8;
    assert.eq r1.validator_index 1u8;
    assert.eq r2.validator_index 2u8;
    assert.eq r3.validator_index 3u8;
    assert.eq r4.validator_index 4u8;
    assert.eq r5.validator_index 5u8;
    assert.eq r6.validator_index 6u8;
    assert.eq r7.validator_index 7u8;
    assert.eq r8.validator_index 8u8;
    assert.eq r9.validator_index 9u8;
    assert.eq r10.validator_index 10u8;
    assert.eq r11.validator_index 11u8;
    assert.eq r12.validator_index 12u8;
    assert.eq r13.validator_index 13u8;
    assert.eq r14.validator_index 14u8;
    assert.eq r15.validator_index 15u8;
    call dcp_beaver_intermediaries.aleo/spend_intermediary_ciphers r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15;
    cast  r0.ciphertext r1.ciphertext r2.ciphertext r3.ciphertext r4.ciphertext r5.ciphertext r6.ciphertext r7.ciphertext r8.ciphertext r9.ciphertext r10.ciphertext r11.ciphertext r12.ciphertext r13.ciphertext r14.ciphertext r15.ciphertext into r16 as [Ciphertext; 16u32];
    cast self.signer r0.triple_index r16 r0.step into r17 as IntermediaryResult.record;
    output r17 as IntermediaryResult.record;







function generate_right_beaver:
    input r0 as scalar.private;
    input r1 as [scalar; 16u32].private;
    input r2 as [scalar; 16u32].private;
    input r3 as [address; 16u32].public;
    input r4 as u8.public;
    input r5 as [field; 15u32].private;
    input r6 as scalar.private;
    input r7 as [field; 15u32].private;
    input r8 as scalar.private;
    input r9 as IntermediaryResult.record;
    not r9.step into r10;
    assert.eq r10 true;
    is.eq 0u8 r4 into r11;
    ternary r11 r3[0u32] aleo1qgqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqanmpl0 into r12;
    is.eq 1u8 r4 into r13;
    ternary r13 r3[1u32] r12 into r14;
    is.eq 2u8 r4 into r15;
    ternary r15 r3[2u32] r14 into r16;
    is.eq 3u8 r4 into r17;
    ternary r17 r3[3u32] r16 into r18;
    is.eq 4u8 r4 into r19;
    ternary r19 r3[4u32] r18 into r20;
    is.eq 5u8 r4 into r21;
    ternary r21 r3[5u32] r20 into r22;
    is.eq 6u8 r4 into r23;
    ternary r23 r3[6u32] r22 into r24;
    is.eq 7u8 r4 into r25;
    ternary r25 r3[7u32] r24 into r26;
    is.eq 8u8 r4 into r27;
    ternary r27 r3[8u32] r26 into r28;
    is.eq 9u8 r4 into r29;
    ternary r29 r3[9u32] r28 into r30;
    is.eq 10u8 r4 into r31;
    ternary r31 r3[10u32] r30 into r32;
    is.eq 11u8 r4 into r33;
    ternary r33 r3[11u32] r32 into r34;
    is.eq 12u8 r4 into r35;
    ternary r35 r3[12u32] r34 into r36;
    is.eq 13u8 r4 into r37;
    ternary r37 r3[13u32] r36 into r38;
    is.eq 14u8 r4 into r39;
    ternary r39 r3[14u32] r38 into r40;
    is.eq 15u8 r4 into r41;
    ternary r41 r3[15u32] r40 into r42;
    assert.eq r42 self.signer;
    is.neq r2[0u32] 0scalar into r43;
    assert.eq r43 true;
    lte r0 1_000_000scalar into r44;
    gte r0 1_000_000scalar into r45;
    or r44 r45 into r46;
    assert.eq r46 true;
    lte r1[0u32] 1_000_000scalar into r47;
    gte r1[0u32] 1_000_000scalar into r48;
    or r47 r48 into r49;
    assert.eq r49 true;
    is.neq r2[1u32] 0scalar into r50;
    assert.eq r50 true;
    lte r0 1_000_000scalar into r51;
    gte r0 1_000_000scalar into r52;
    or r51 r52 into r53;
    assert.eq r53 true;
    lte r1[1u32] 1_000_000scalar into r54;
    gte r1[1u32] 1_000_000scalar into r55;
    or r54 r55 into r56;
    assert.eq r56 true;
    is.neq r2[2u32] 0scalar into r57;
    assert.eq r57 true;
    lte r0 1_000_000scalar into r58;
    gte r0 1_000_000scalar into r59;
    or r58 r59 into r60;
    assert.eq r60 true;
    lte r1[2u32] 1_000_000scalar into r61;
    gte r1[2u32] 1_000_000scalar into r62;
    or r61 r62 into r63;
    assert.eq r63 true;
    is.neq r2[3u32] 0scalar into r64;
    assert.eq r64 true;
    lte r0 1_000_000scalar into r65;
    gte r0 1_000_000scalar into r66;
    or r65 r66 into r67;
    assert.eq r67 true;
    lte r1[3u32] 1_000_000scalar into r68;
    gte r1[3u32] 1_000_000scalar into r69;
    or r68 r69 into r70;
    assert.eq r70 true;
    is.neq r2[4u32] 0scalar into r71;
    assert.eq r71 true;
    lte r0 1_000_000scalar into r72;
    gte r0 1_000_000scalar into r73;
    or r72 r73 into r74;
    assert.eq r74 true;
    lte r1[4u32] 1_000_000scalar into r75;
    gte r1[4u32] 1_000_000scalar into r76;
    or r75 r76 into r77;
    assert.eq r77 true;
    is.neq r2[5u32] 0scalar into r78;
    assert.eq r78 true;
    lte r0 1_000_000scalar into r79;
    gte r0 1_000_000scalar into r80;
    or r79 r80 into r81;
    assert.eq r81 true;
    lte r1[5u32] 1_000_000scalar into r82;
    gte r1[5u32] 1_000_000scalar into r83;
    or r82 r83 into r84;
    assert.eq r84 true;
    is.neq r2[6u32] 0scalar into r85;
    assert.eq r85 true;
    lte r0 1_000_000scalar into r86;
    gte r0 1_000_000scalar into r87;
    or r86 r87 into r88;
    assert.eq r88 true;
    lte r1[6u32] 1_000_000scalar into r89;
    gte r1[6u32] 1_000_000scalar into r90;
    or r89 r90 into r91;
    assert.eq r91 true;
    is.neq r2[7u32] 0scalar into r92;
    assert.eq r92 true;
    lte r0 1_000_000scalar into r93;
    gte r0 1_000_000scalar into r94;
    or r93 r94 into r95;
    assert.eq r95 true;
    lte r1[7u32] 1_000_000scalar into r96;
    gte r1[7u32] 1_000_000scalar into r97;
    or r96 r97 into r98;
    assert.eq r98 true;
    is.neq r2[8u32] 0scalar into r99;
    assert.eq r99 true;
    lte r0 1_000_000scalar into r100;
    gte r0 1_000_000scalar into r101;
    or r100 r101 into r102;
    assert.eq r102 true;
    lte r1[8u32] 1_000_000scalar into r103;
    gte r1[8u32] 1_000_000scalar into r104;
    or r103 r104 into r105;
    assert.eq r105 true;
    is.neq r2[9u32] 0scalar into r106;
    assert.eq r106 true;
    lte r0 1_000_000scalar into r107;
    gte r0 1_000_000scalar into r108;
    or r107 r108 into r109;
    assert.eq r109 true;
    lte r1[9u32] 1_000_000scalar into r110;
    gte r1[9u32] 1_000_000scalar into r111;
    or r110 r111 into r112;
    assert.eq r112 true;
    is.neq r2[10u32] 0scalar into r113;
    assert.eq r113 true;
    lte r0 1_000_000scalar into r114;
    gte r0 1_000_000scalar into r115;
    or r114 r115 into r116;
    assert.eq r116 true;
    lte r1[10u32] 1_000_000scalar into r117;
    gte r1[10u32] 1_000_000scalar into r118;
    or r117 r118 into r119;
    assert.eq r119 true;
    is.neq r2[11u32] 0scalar into r120;
    assert.eq r120 true;
    lte r0 1_000_000scalar into r121;
    gte r0 1_000_000scalar into r122;
    or r121 r122 into r123;
    assert.eq r123 true;
    lte r1[11u32] 1_000_000scalar into r124;
    gte r1[11u32] 1_000_000scalar into r125;
    or r124 r125 into r126;
    assert.eq r126 true;
    is.neq r2[12u32] 0scalar into r127;
    assert.eq r127 true;
    lte r0 1_000_000scalar into r128;
    gte r0 1_000_000scalar into r129;
    or r128 r129 into r130;
    assert.eq r130 true;
    lte r1[12u32] 1_000_000scalar into r131;
    gte r1[12u32] 1_000_000scalar into r132;
    or r131 r132 into r133;
    assert.eq r133 true;
    is.neq r2[13u32] 0scalar into r134;
    assert.eq r134 true;
    lte r0 1_000_000scalar into r135;
    gte r0 1_000_000scalar into r136;
    or r135 r136 into r137;
    assert.eq r137 true;
    lte r1[13u32] 1_000_000scalar into r138;
    gte r1[13u32] 1_000_000scalar into r139;
    or r138 r139 into r140;
    assert.eq r140 true;
    is.neq r2[14u32] 0scalar into r141;
    assert.eq r141 true;
    lte r0 1_000_000scalar into r142;
    gte r0 1_000_000scalar into r143;
    or r142 r143 into r144;
    assert.eq r144 true;
    lte r1[14u32] 1_000_000scalar into r145;
    gte r1[14u32] 1_000_000scalar into r146;
    or r145 r146 into r147;
    assert.eq r147 true;
    is.neq r2[15u32] 0scalar into r148;
    assert.eq r148 true;
    lte r0 1_000_000scalar into r149;
    gte r0 1_000_000scalar into r150;
    or r149 r150 into r151;
    assert.eq r151 true;
    lte r1[15u32] 1_000_000scalar into r152;
    gte r1[15u32] 1_000_000scalar into r153;
    or r152 r153 into r154;
    assert.eq r154 true;
    mul r0 r9.ciphertexts[0u32].value_ into r155;
    mul r0 r9.ciphertexts[0u32].nonce into r156;
    cast r155 r156 into r157 as Ciphertext;
    mul r2[0u32] 522678458525321116977504528531602186870683848189190546523208313015552693483group into r158;
    cast r3[0u32] into r159 as group;
    mul r2[0u32] r159 into r160;
    mul r1[0u32] group::GEN into r161;
    add r161 r160 into r162;
    cast r162 r158 into r163 as Ciphertext;
    add r157.value_ r163.value_ into r164;
    add r157.nonce r163.nonce into r165;
    cast r164 r165 into r166 as Ciphertext;
    mul r0 r9.ciphertexts[1u32].value_ into r167;
    mul r0 r9.ciphertexts[1u32].nonce into r168;
    cast r167 r168 into r169 as Ciphertext;
    mul r2[1u32] 522678458525321116977504528531602186870683848189190546523208313015552693483group into r170;
    cast r3[1u32] into r171 as group;
    mul r2[1u32] r171 into r172;
    mul r1[1u32] group::GEN into r173;
    add r173 r172 into r174;
    cast r174 r170 into r175 as Ciphertext;
    add r169.value_ r175.value_ into r176;
    add r169.nonce r175.nonce into r177;
    cast r176 r177 into r178 as Ciphertext;
    mul r0 r9.ciphertexts[2u32].value_ into r179;
    mul r0 r9.ciphertexts[2u32].nonce into r180;
    cast r179 r180 into r181 as Ciphertext;
    mul r2[2u32] 522678458525321116977504528531602186870683848189190546523208313015552693483group into r182;
    cast r3[2u32] into r183 as group;
    mul r2[2u32] r183 into r184;
    mul r1[2u32] group::GEN into r185;
    add r185 r184 into r186;
    cast r186 r182 into r187 as Ciphertext;
    add r181.value_ r187.value_ into r188;
    add r181.nonce r187.nonce into r189;
    cast r188 r189 into r190 as Ciphertext;
    mul r0 r9.ciphertexts[3u32].value_ into r191;
    mul r0 r9.ciphertexts[3u32].nonce into r192;
    cast r191 r192 into r193 as Ciphertext;
    mul r2[3u32] 522678458525321116977504528531602186870683848189190546523208313015552693483group into r194;
    cast r3[3u32] into r195 as group;
    mul r2[3u32] r195 into r196;
    mul r1[3u32] group::GEN into r197;
    add r197 r196 into r198;
    cast r198 r194 into r199 as Ciphertext;
    add r193.value_ r199.value_ into r200;
    add r193.nonce r199.nonce into r201;
    cast r200 r201 into r202 as Ciphertext;
    mul r0 r9.ciphertexts[4u32].value_ into r203;
    mul r0 r9.ciphertexts[4u32].nonce into r204;
    cast r203 r204 into r205 as Ciphertext;
    mul r2[4u32] 522678458525321116977504528531602186870683848189190546523208313015552693483group into r206;
    cast r3[4u32] into r207 as group;
    mul r2[4u32] r207 into r208;
    mul r1[4u32] group::GEN into r209;
    add r209 r208 into r210;
    cast r210 r206 into r211 as Ciphertext;
    add r205.value_ r211.value_ into r212;
    add r205.nonce r211.nonce into r213;
    cast r212 r213 into r214 as Ciphertext;
    mul r0 r9.ciphertexts[5u32].value_ into r215;
    mul r0 r9.ciphertexts[5u32].nonce into r216;
    cast r215 r216 into r217 as Ciphertext;
    mul r2[5u32] 522678458525321116977504528531602186870683848189190546523208313015552693483group into r218;
    cast r3[5u32] into r219 as group;
    mul r2[5u32] r219 into r220;
    mul r1[5u32] group::GEN into r221;
    add r221 r220 into r222;
    cast r222 r218 into r223 as Ciphertext;
    add r217.value_ r223.value_ into r224;
    add r217.nonce r223.nonce into r225;
    cast r224 r225 into r226 as Ciphertext;
    mul r0 r9.ciphertexts[6u32].value_ into r227;
    mul r0 r9.ciphertexts[6u32].nonce into r228;
    cast r227 r228 into r229 as Ciphertext;
    mul r2[6u32] 522678458525321116977504528531602186870683848189190546523208313015552693483group into r230;
    cast r3[6u32] into r231 as group;
    mul r2[6u32] r231 into r232;
    mul r1[6u32] group::GEN into r233;
    add r233 r232 into r234;
    cast r234 r230 into r235 as Ciphertext;
    add r229.value_ r235.value_ into r236;
    add r229.nonce r235.nonce into r237;
    cast r236 r237 into r238 as Ciphertext;
    mul r0 r9.ciphertexts[7u32].value_ into r239;
    mul r0 r9.ciphertexts[7u32].nonce into r240;
    cast r239 r240 into r241 as Ciphertext;
    mul r2[7u32] 522678458525321116977504528531602186870683848189190546523208313015552693483group into r242;
    cast r3[7u32] into r243 as group;
    mul r2[7u32] r243 into r244;
    mul r1[7u32] group::GEN into r245;
    add r245 r244 into r246;
    cast r246 r242 into r247 as Ciphertext;
    add r241.value_ r247.value_ into r248;
    add r241.nonce r247.nonce into r249;
    cast r248 r249 into r250 as Ciphertext;
    mul r0 r9.ciphertexts[8u32].value_ into r251;
    mul r0 r9.ciphertexts[8u32].nonce into r252;
    cast r251 r252 into r253 as Ciphertext;
    mul r2[8u32] 522678458525321116977504528531602186870683848189190546523208313015552693483group into r254;
    cast r3[8u32] into r255 as group;
    mul r2[8u32] r255 into r256;
    mul r1[8u32] group::GEN into r257;
    add r257 r256 into r258;
    cast r258 r254 into r259 as Ciphertext;
    add r253.value_ r259.value_ into r260;
    add r253.nonce r259.nonce into r261;
    cast r260 r261 into r262 as Ciphertext;
    mul r0 r9.ciphertexts[9u32].value_ into r263;
    mul r0 r9.ciphertexts[9u32].nonce into r264;
    cast r263 r264 into r265 as Ciphertext;
    mul r2[9u32] 522678458525321116977504528531602186870683848189190546523208313015552693483group into r266;
    cast r3[9u32] into r267 as group;
    mul r2[9u32] r267 into r268;
    mul r1[9u32] group::GEN into r269;
    add r269 r268 into r270;
    cast r270 r266 into r271 as Ciphertext;
    add r265.value_ r271.value_ into r272;
    add r265.nonce r271.nonce into r273;
    cast r272 r273 into r274 as Ciphertext;
    mul r0 r9.ciphertexts[10u32].value_ into r275;
    mul r0 r9.ciphertexts[10u32].nonce into r276;
    cast r275 r276 into r277 as Ciphertext;
    mul r2[10u32] 522678458525321116977504528531602186870683848189190546523208313015552693483group into r278;
    cast r3[10u32] into r279 as group;
    mul r2[10u32] r279 into r280;
    mul r1[10u32] group::GEN into r281;
    add r281 r280 into r282;
    cast r282 r278 into r283 as Ciphertext;
    add r277.value_ r283.value_ into r284;
    add r277.nonce r283.nonce into r285;
    cast r284 r285 into r286 as Ciphertext;
    mul r0 r9.ciphertexts[11u32].value_ into r287;
    mul r0 r9.ciphertexts[11u32].nonce into r288;
    cast r287 r288 into r289 as Ciphertext;
    mul r2[11u32] 522678458525321116977504528531602186870683848189190546523208313015552693483group into r290;
    cast r3[11u32] into r291 as group;
    mul r2[11u32] r291 into r292;
    mul r1[11u32] group::GEN into r293;
    add r293 r292 into r294;
    cast r294 r290 into r295 as Ciphertext;
    add r289.value_ r295.value_ into r296;
    add r289.nonce r295.nonce into r297;
    cast r296 r297 into r298 as Ciphertext;
    mul r0 r9.ciphertexts[12u32].value_ into r299;
    mul r0 r9.ciphertexts[12u32].nonce into r300;
    cast r299 r300 into r301 as Ciphertext;
    mul r2[12u32] 522678458525321116977504528531602186870683848189190546523208313015552693483group into r302;
    cast r3[12u32] into r303 as group;
    mul r2[12u32] r303 into r304;
    mul r1[12u32] group::GEN into r305;
    add r305 r304 into r306;
    cast r306 r302 into r307 as Ciphertext;
    add r301.value_ r307.value_ into r308;
    add r301.nonce r307.nonce into r309;
    cast r308 r309 into r310 as Ciphertext;
    mul r0 r9.ciphertexts[13u32].value_ into r311;
    mul r0 r9.ciphertexts[13u32].nonce into r312;
    cast r311 r312 into r313 as Ciphertext;
    mul r2[13u32] 522678458525321116977504528531602186870683848189190546523208313015552693483group into r314;
    cast r3[13u32] into r315 as group;
    mul r2[13u32] r315 into r316;
    mul r1[13u32] group::GEN into r317;
    add r317 r316 into r318;
    cast r318 r314 into r319 as Ciphertext;
    add r313.value_ r319.value_ into r320;
    add r313.nonce r319.nonce into r321;
    cast r320 r321 into r322 as Ciphertext;
    mul r0 r9.ciphertexts[14u32].value_ into r323;
    mul r0 r9.ciphertexts[14u32].nonce into r324;
    cast r323 r324 into r325 as Ciphertext;
    mul r2[14u32] 522678458525321116977504528531602186870683848189190546523208313015552693483group into r326;
    cast r3[14u32] into r327 as group;
    mul r2[14u32] r327 into r328;
    mul r1[14u32] group::GEN into r329;
    add r329 r328 into r330;
    cast r330 r326 into r331 as Ciphertext;
    add r325.value_ r331.value_ into r332;
    add r325.nonce r331.nonce into r333;
    cast r332 r333 into r334 as Ciphertext;
    mul r0 r9.ciphertexts[15u32].value_ into r335;
    mul r0 r9.ciphertexts[15u32].nonce into r336;
    cast r335 r336 into r337 as Ciphertext;
    mul r2[15u32] 522678458525321116977504528531602186870683848189190546523208313015552693483group into r338;
    cast r3[15u32] into r339 as group;
    mul r2[15u32] r339 into r340;
    mul r1[15u32] group::GEN into r341;
    add r341 r340 into r342;
    cast r342 r338 into r343 as Ciphertext;
    add r337.value_ r343.value_ into r344;
    add r337.nonce r343.nonce into r345;
    cast r344 r345 into r346 as Ciphertext;
    cast  r166 r178 r190 r202 r214 r226 r238 r250 r262 r274 r286 r298 r310 r322 r334 r346 into r347 as [Ciphertext; 16u32];
    call dcp_beaver_intermediaries.aleo/sumbit_right_ciphers r3 r9.triple_index r4 r347 into r348 r349 r350 r351 r352 r353 r354 r355 r356 r357 r358 r359 r360 r361 r362 r363;
    cast r9.triple_index 1u8 r3 into r364 as Beaver;
    hash.bhp256 r364 into r365 as field;
    cast r0 into r366 as field;
    call data_custody_protocol.aleo/add_or_mul_private r366 true r365 r5 r3 16u8 r6 into r367;
    cast r9.triple_index 2u8 r3 into r368 as Beaver;
    hash.bhp256 r368 into r369 as field;
    add 0scalar r1[0u32] into r370;
    add r370 r1[1u32] into r371;
    add r371 r1[2u32] into r372;
    add r372 r1[3u32] into r373;
    add r373 r1[4u32] into r374;
    add r374 r1[5u32] into r375;
    add r375 r1[6u32] into r376;
    add r376 r1[7u32] into r377;
    add r377 r1[8u32] into r378;
    add r378 r1[9u32] into r379;
    add r379 r1[10u32] into r380;
    add r380 r1[11u32] into r381;
    add r381 r1[12u32] into r382;
    add r382 r1[13u32] into r383;
    add r383 r1[14u32] into r384;
    add r384 r1[15u32] into r385;
    cast r385 into r386 as field;
    neg r386 into r387;
    call data_custody_protocol.aleo/add_or_mul_private r387 true r369 r7 r3 16u8 r8 into r388;
    async generate_right_beaver r367 r388 into r389;
    output r389 as dcp_beaver_triples.aleo/generate_right_beaver.future;

finalize generate_right_beaver:
    input r0 as data_custody_protocol.aleo/add_or_mul_private.future;
    input r1 as data_custody_protocol.aleo/add_or_mul_private.future;
    await r0;
    await r1;






function generate_sum_beaver:
    input r0 as [address; 16u32].public;
    input r1 as u8.public;
    input r2 as [field; 15u32].private;
    input r3 as scalar.private;
    input r4 as scalar.private;
    input r5 as IntermediaryResult.record;
    input r6 as [scalar; 16u32].private;
    is.eq 0u8 r1 into r7;
    ternary r7 r0[0u32] aleo1qgqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqanmpl0 into r8;
    is.eq 1u8 r1 into r9;
    ternary r9 r0[1u32] r8 into r10;
    is.eq 2u8 r1 into r11;
    ternary r11 r0[2u32] r10 into r12;
    is.eq 3u8 r1 into r13;
    ternary r13 r0[3u32] r12 into r14;
    is.eq 4u8 r1 into r15;
    ternary r15 r0[4u32] r14 into r16;
    is.eq 5u8 r1 into r17;
    ternary r17 r0[5u32] r16 into r18;
    is.eq 6u8 r1 into r19;
    ternary r19 r0[6u32] r18 into r20;
    is.eq 7u8 r1 into r21;
    ternary r21 r0[7u32] r20 into r22;
    is.eq 8u8 r1 into r23;
    ternary r23 r0[8u32] r22 into r24;
    is.eq 9u8 r1 into r25;
    ternary r25 r0[9u32] r24 into r26;
    is.eq 10u8 r1 into r27;
    ternary r27 r0[10u32] r26 into r28;
    is.eq 11u8 r1 into r29;
    ternary r29 r0[11u32] r28 into r30;
    is.eq 12u8 r1 into r31;
    ternary r31 r0[12u32] r30 into r32;
    is.eq 13u8 r1 into r33;
    ternary r33 r0[13u32] r32 into r34;
    is.eq 14u8 r1 into r35;
    ternary r35 r0[14u32] r34 into r36;
    is.eq 15u8 r1 into r37;
    ternary r37 r0[15u32] r36 into r38;
    assert.eq r38 self.signer;
    mul r4 522678458525321116977504528531602186870683848189190546523208313015552693483group into r39;
    cast r39 into r40 as address;
    assert.eq self.signer r40;
    assert.eq r5.step true;
    add 0scalar r6[0u32] into r41;
    mul r4 r5.ciphertexts[0u32].nonce into r42;
    cast r42 into r43 as field;
    mul r6[0u32] group::GEN into r44;
    sub r5.ciphertexts[0u32].value_ r42 into r45;
    assert.eq r44 r45;
    add r41 r6[1u32] into r46;
    mul r4 r5.ciphertexts[1u32].nonce into r47;
    cast r47 into r48 as field;
    mul r6[1u32] group::GEN into r49;
    sub r5.ciphertexts[1u32].value_ r47 into r50;
    assert.eq r49 r50;
    add r46 r6[2u32] into r51;
    mul r4 r5.ciphertexts[2u32].nonce into r52;
    cast r52 into r53 as field;
    mul r6[2u32] group::GEN into r54;
    sub r5.ciphertexts[2u32].value_ r52 into r55;
    assert.eq r54 r55;
    add r51 r6[3u32] into r56;
    mul r4 r5.ciphertexts[3u32].nonce into r57;
    cast r57 into r58 as field;
    mul r6[3u32] group::GEN into r59;
    sub r5.ciphertexts[3u32].value_ r57 into r60;
    assert.eq r59 r60;
    add r56 r6[4u32] into r61;
    mul r4 r5.ciphertexts[4u32].nonce into r62;
    cast r62 into r63 as field;
    mul r6[4u32] group::GEN into r64;
    sub r5.ciphertexts[4u32].value_ r62 into r65;
    assert.eq r64 r65;
    add r61 r6[5u32] into r66;
    mul r4 r5.ciphertexts[5u32].nonce into r67;
    cast r67 into r68 as field;
    mul r6[5u32] group::GEN into r69;
    sub r5.ciphertexts[5u32].value_ r67 into r70;
    assert.eq r69 r70;
    add r66 r6[6u32] into r71;
    mul r4 r5.ciphertexts[6u32].nonce into r72;
    cast r72 into r73 as field;
    mul r6[6u32] group::GEN into r74;
    sub r5.ciphertexts[6u32].value_ r72 into r75;
    assert.eq r74 r75;
    add r71 r6[7u32] into r76;
    mul r4 r5.ciphertexts[7u32].nonce into r77;
    cast r77 into r78 as field;
    mul r6[7u32] group::GEN into r79;
    sub r5.ciphertexts[7u32].value_ r77 into r80;
    assert.eq r79 r80;
    add r76 r6[8u32] into r81;
    mul r4 r5.ciphertexts[8u32].nonce into r82;
    cast r82 into r83 as field;
    mul r6[8u32] group::GEN into r84;
    sub r5.ciphertexts[8u32].value_ r82 into r85;
    assert.eq r84 r85;
    add r81 r6[9u32] into r86;
    mul r4 r5.ciphertexts[9u32].nonce into r87;
    cast r87 into r88 as field;
    mul r6[9u32] group::GEN into r89;
    sub r5.ciphertexts[9u32].value_ r87 into r90;
    assert.eq r89 r90;
    add r86 r6[10u32] into r91;
    mul r4 r5.ciphertexts[10u32].nonce into r92;
    cast r92 into r93 as field;
    mul r6[10u32] group::GEN into r94;
    sub r5.ciphertexts[10u32].value_ r92 into r95;
    assert.eq r94 r95;
    add r91 r6[11u32] into r96;
    mul r4 r5.ciphertexts[11u32].nonce into r97;
    cast r97 into r98 as field;
    mul r6[11u32] group::GEN into r99;
    sub r5.ciphertexts[11u32].value_ r97 into r100;
    assert.eq r99 r100;
    add r96 r6[12u32] into r101;
    mul r4 r5.ciphertexts[12u32].nonce into r102;
    cast r102 into r103 as field;
    mul r6[12u32] group::GEN into r104;
    sub r5.ciphertexts[12u32].value_ r102 into r105;
    assert.eq r104 r105;
    add r101 r6[13u32] into r106;
    mul r4 r5.ciphertexts[13u32].nonce into r107;
    cast r107 into r108 as field;
    mul r6[13u32] group::GEN into r109;
    sub r5.ciphertexts[13u32].value_ r107 into r110;
    assert.eq r109 r110;
    add r106 r6[14u32] into r111;
    mul r4 r5.ciphertexts[14u32].nonce into r112;
    cast r112 into r113 as field;
    mul r6[14u32] group::GEN into r114;
    sub r5.ciphertexts[14u32].value_ r112 into r115;
    assert.eq r114 r115;
    add r111 r6[15u32] into r116;
    mul r4 r5.ciphertexts[15u32].nonce into r117;
    cast r117 into r118 as field;
    mul r6[15u32] group::GEN into r119;
    sub r5.ciphertexts[15u32].value_ r117 into r120;
    assert.eq r119 r120;
    cast r5.triple_index 2u8 r0 into r121 as Beaver;
    hash.bhp256 r121 into r122 as field;
    cast r116 into r123 as field;
    call data_custody_protocol.aleo/add_or_mul_private r123 true r122 r2 r0 16u8 r3 into r124;
    async generate_sum_beaver r124 into r125;
    output r125 as dcp_beaver_triples.aleo/generate_sum_beaver.future;

finalize generate_sum_beaver:
    input r0 as data_custody_protocol.aleo/add_or_mul_private.future;
    await r0;

